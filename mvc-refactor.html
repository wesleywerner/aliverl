<h1 id="table-of-contents">Table of contents</h1>
<div class="toc">
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#the-purpose-of-this-document">The purpose of this document</a><ul>
<li><a href="#versions">Versions</a></li>
</ul>
</li>
<li><a href="#the-coupling">The coupling</a></li>
<li><a href="#game-states">Game states</a><ul>
<li><a href="#state-implementation">State implementation</a><ul>
<li><a href="#what-is-a-state-machine">What is a state machine?</a></li>
<li><a href="#why-would-we-do-this">Why would we do this?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-code">The Code</a><ul>
<li><a href="#the-model">The Model</a></li>
<li><a href="#the-view">The View</a></li>
</ul>
</li>
<li><a href="#rendering-the-level">Rendering the level</a><ul>
<li><a href="#where-the-rendering-code-lives">Where the rendering code lives</a></li>
</ul>
</li>
<li><a href="#restructuring">Restructuring</a></li>
<li><a href="#license">License</a></li>
<li><a href="#contact">Contact</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<h1 id="the-purpose-of-this-document">The purpose of this document</h1>
<p>Implement the MVC design pattern for a 2D graphical RPG Roguelike game.
By decoupling the view, controller and model and using an event manager to
communicate between them, we make the code more maintainable and allow us to
implement other neat controllers like:</p>
<ul>
<li>a View for graphic on mobile devices.</li>
<li>a Controller for touch-screens.</li>
</ul>
<p><em>For more on MVC patters see References below</em></p>
<h2 id="versions">Versions</h2>
<p>This document is a work in progress and incomplete.</p>
<ol>
<li>2013/03: drafting</li>
</ol>
<h1 id="the-coupling">The coupling</h1>
<p>Here we see how our our model pieces are connected:</p>
<pre><code>             +------------+
             |    Model   |
  &gt;----&gt;----&gt;+------------+&lt;----&lt;----&lt;
  |          .            .          |
  ^          .            .          ^
  |          +------------+          |
  ^          |   Events   |          ^
  |          +------------+          |
  ^          .            .          ^
  |          .            .          |
  ^          .            .          ^
  +------------+        +------------+
  |    View    |        | Controller |
  +------------+        +------------+
</code></pre>
<ul>
<li>Model<ul>
<li>job: stores game map, player and npc data, game settings. Everything data.</li>
<li>is not aware of what Views or Controllers are looking at it.</li>
<li>can post and listen for events.</li>
</ul>
</li>
<li>View<ul>
<li>job: draws on screen what the model represents.</li>
<li>is strongly aware of the model and it's values.</li>
<li>can post and listen for events.</li>
</ul>
</li>
<li>Controller<ul>
<li>job: taking keyboard and mouse input and posts matching events.</li>
<li>is strongly aware of the model and it's values.</li>
<li>can post and listen for events.</li>
</ul>
</li>
<li>Events<ul>
<li>job: coordinates messages between listeners.</li>
</ul>
</li>
</ul>
<p>This shows that even if the Controller does not know anything about the player's
health, what level we are on, it still only catches key presses and sends out
events to match.</p>
<p>Nor does the View care how the player is controlling our game. 
The View only cares about showing on screen the current model state.
Since the View also listens to posted events, it will pick up mouse clicks and
key presses that integrate into it's widgets.</p>
<h1 id="game-states">Game states</h1>
<p>The model is host to multiple game states, like:</p>
<ul>
<li>playing<ul>
<li>The game is in play.</li>
<li>Controls react to the playtime context.</li>
</ul>
</li>
<li>dialogue<ul>
<li>The screen shows game storyline.</li>
<li>The game is not running.</li>
<li>Controls only respond to the dialog context.</li>
</ul>
</li>
<li>menus<ul>
<li>The user can select a profile to play or continue play.</li>
<li>The user can select to view the settings or other pages.</li>
<li>The game is not running. </li>
<li>Controls only respond to the menu context.</li>
</ul>
</li>
<li>settings<ul>
<li>The user can toggle audio or music.</li>
<li>The game is not running.</li>
<li>Controls only respond to the settings context.</li>
</ul>
</li>
<li>intro<ul>
<li>Shows opening screen.</li>
</ul>
</li>
<li>help<ul>
<li>Display a game help overlay.</li>
</ul>
</li>
</ul>
<p>Since our View and Controller has strong links to the Model, both can look at
the Model state, and decide what user keys to process, and what to draw.</p>
<p>That is their domain, and their job.</p>
<h2 id="state-implementation">State implementation</h2>
<p>Using a state machine to track these game states allows us interesting tricks otherwise difficult to do.</p>
<h3 id="what-is-a-state-machine">What is a state machine?</h3>
<p>It is a fancy name for "a list of values, Last one In is First one Out." LIFO.</p>
<p>Think of it like a stack of dinner plates.</p>
<pre><code>          ===     &lt;- we have a green plate on the table
        #######   &lt;- our wooden breakfast table
</code></pre>
<p>You can peek() at what the topmost plate is, we see it is green, so we draw and react to events that mean "our game is busy playing". </p>
<p>When we push() a red plate on top of the stack, we draw and do things that mean "the game is now paused". </p>
<pre><code>          ===     &lt;- we now see a red plate on top of the stack
          ===     ... green plate
        #######   ... table
</code></pre>
<p>To unpause, we simply pop() the top most plate off the stack, and we can now see the green plate again. Our game carries on playing.</p>
<h3 id="why-would-we-do-this">Why would we do this?</h3>
<p>Because this allows us to easily unwind the stack to escape from game menus, options, dialogue screens and so forth.</p>
<p>All our View needs to do, is draw whatever the current stack item says.
All our Controller needs to do, is handle input for the current stack item.</p>
<p>We can use this to show game dialogue for more than one screen. Consider this:</p>
<pre><code>          ===     ... dialogue text #1
          ===     ... dialogue text #2
          ===     ... dialogue text #3
          ===     ... green plate
        #######   ... table
</code></pre>
<p>The View draws the dialogue text #1, and when the user presses the "anykey" we pop the stack and suddenly the View draws text #2. Neat. </p>
<p>The Controller knows it's a dialogue mode and knows to pop the stack on the "anykey" press. </p>
<p>Press enough keys, pop enough plates, we move through the storyline and get back to the game.</p>
<h1 id="the-code">The Code</h1>
<p>Now we can implement our MVC pattern in <a href="http://python.org">Python</a>. We will create the Model, the View and the Controller.
We will also create the file that hosts instances of each and links them together.</p>
<p>We will use the <a href="http://pygame.org">PyGame</a> library for our View's graphics. The whole MVC design will allow us to replace PyGame with another graphics library if that is our wish. The game's behaviour will stay the same since the View does not control how the game runs, cutting out many potential bugs when refactoring another View.</p>
<p><em>our coding style is taken from <a href="http://www.python.org/dev/peps/pep-0008/">PEP8</a>. Read it. :)</em></p>
<p>We will now create:</p>
<ul>
<li>model.py, the brain.</li>
<li>view.py, draws what the brain thinks.</li>
<li>controller.py, tells the brain what to do.</li>
<li>eventmanager.py, coordinates all our senses.</li>
<li>main.py, glues all of the above into a running instance.</li>
</ul>
<h2 id="the-model">The Model</h2>
<p>Let's start with the brain of our game. Check this out:</p>
<p><em>Model.py</em></p>
<hr />
<pre><code>import pygame
from eventmanager import *

class GameEngine(object):
    """
    Tracks the game state.
    """

    def __init__(self, evManager):
        """
        evManager (EventManager): Allows posting messages to the event queue.

        Attributes:
        running (bool): True while the engine is online. Changed via QuitEvent().
        """

        self.evManager = evManager
        evManager.RegisterListener(self)
        self.running = False

    def notify(self, event):
        """
        Called by an event in the message queue. 
        """

        if isinstance(event, QuitEvent):
            self.running = False

    def run(self):
        """
        Starts the game engine loop.

        This pumps a Tick event into the message queue for each loop.
        The loop ends when this object hears a QuitEvent in notify(). 
        """
        self.running = True
        self.evManager.Post(InitializeEvent())
        while self.running:
            newTick = TickEvent()
            self.evManager.Post(newTick)
</code></pre>
<hr />
<p>You can see the Model takes an instance of Event Manager, this is so we can post() messages from the Model. Any messages sent there are received into notify(), this includes messages posted by other instances. The run() method simply tells all other message listeners to get ready for action (InitializeEvent) and then starts posting TickEvents, forever, until it hears a QuitEvent through notify(). note how the Model imports eventmanager (line 1), but no View or Controller! The Model is blind to what is watching or controlling it, that is done all through the message pump.</p>
<h2 id="the-view">The View</h2>
<p>Next up we code the View. First you will note it imports eventmanager, and the model. We call this a strong reference to the model, because we explicitly code against the model's properties. Because we are only a View, we should try and limit our selves to only read the model data, and avoid calling it's functions directly - of course nothing stops you from making direct calls, but the MVC pattern for a View hints to us that we only display the Model state.</p>
<p><em>view.py</em></p>
<hr />
<pre><code>import pygame
import model
from eventmanager import *

class GraphicalView(object):
    """
    Draws the model state onto the screen.
    """

    def __init__(self, evManager, model):
        """
        evManager (EventManager): Allows posting messages to the event queue.
        model (GameEngine): a strong reference to the game Model.

        Attributes:
        isinitialized (bool): pygame is ready to draw.
        screen (pygame.Surface): the screen surface.
        clock (pygame.time.Clock): keeps the fps constant.
        smallfont (pygame.Font): a small font.
        """

        self.evManager = evManager
        evManager.RegisterListener(self)
        self.model = model
        self.isinitialized = False
        self.screen = None
        self.clock = None
        self.smallfont = None

    def notify(self, event):
        """
        Receive events posted to the message queue. 
        """

        if isinstance(event, InitializeEvent):
            self.initialize()
        elif isinstance(event, QuitEvent):
            # shut down the pygame graphics
            self.isinitialized = False
            pygame.quit()
        elif isinstance(event, TickEvent):
            self.renderall()
            # limit the redraw speed to 30 frames per second
            self.clock.tick(30)

    def renderall(self):
        """
        Draw the current game state on screen.
        Does nothing if isinitialized == False (pygame.init failed)
        """

        if not self.isinitialized:
            return
        # clear display
        self.screen.fill((0, 0, 0))
        # draw some words on the screen
        somewords = self.smallfont.render(
                    'The View is busy drawing on your screen', 
                    True, 
                    (0, 255, 0))
        self.screen.blit(somewords, (0, 0))
        # flip the display to show whatever we drew
        pygame.display.flip()

    def initialize(self):
        """
        Set up the pygame graphical display and loads graphical resources.
        """

        result = pygame.init()
        pygame.font.init()
        pygame.display.set_caption('MVC game')
        self.screen = pygame.display.set_mode((800, 512))
        self.clock = pygame.time.Clock()
        self.smallfont = pygame.font.Font(None, 40)
        self.isinitialized = True
</code></pre>
<hr />
<h1 id="rendering-the-level">Rendering the level</h1>
<p>We will use the Tiled map editor to create game levels, and the PyTMX library for reading the level files - See <a href="#references">References</a> below for links to these great pieces of code :]</p>
<p>The best way to learn a library is to work through the included demo code.</p>
<p>Read through the demo and mentally note the classes it uses. Then browse those
class sources and go through their properties and functions. </p>
<p>This will take some time, but it is rewarding when you use the library someone else has worked on. We can only thank them for their hard work!</p>
<h2 id="where-the-rendering-code-lives">Where the rendering code lives</h2>
<p>In our MVC model, everything that involves drawing goes into the View.</p>
<h1 id="restructuring">Restructuring</h1>
<p>Existing code files will be restructured.
(<em>slanted files await refactoring</em>)</p>
<p><strong>MODEL</strong>: aliveModel.py</p>
<ul>
<li><em>game.py</em></li>
<li><em>character.py</em></li>
<li><em>objects.py</em></li>
<li>states.py</li>
<li><em>stats.py</em></li>
<li><em>combat.py</em></li>
<li><em>bump.py</em></li>
<li><em>level.py</em></li>
<li><em>messages.py</em></li>
</ul>
<p><strong>VIEW</strong>: aliveView.py</p>
<ul>
<li>resources.py</li>
<li><em>ui.py</em></li>
<li><em>helper.py</em></li>
<li><em>audio.py</em></li>
</ul>
<p><strong>CONTROLLER</strong>: aliveController.py</p>
<ul>
<li>input.py</li>
</ul>
<p><strong>OTHER</strong>:</p>
<ul>
<li>alive.py<ul>
<li>binds the mvc objects together</li>
</ul>
</li>
<li>eventmanager.py<ul>
<li>pygame provides an event manager but we implement our own so it is not coupled to pygame.</li>
</ul>
</li>
<li>trace.py</li>
<li>color.py</li>
</ul>
<h1 id="license">License</h1>
<pre><code>Copyright (C) 2013 Wesley Werner

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
</code></pre>
<p>You should have received a copy of the GNU General Public License along with this program.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<h1 id="contact">Contact</h1>
<p>You may contact me at <a href="mailto:wez@[anti-spam]darknet.co.za">wez@[anti-spam]darknet.co.za</a></p>
<h1 id="references">References</h1>
<ul>
<li>
<p><a href="http://mapeditor.org">http://mapeditor.org</a>: A 2D tiled map editor.</p>
</li>
<li>
<p><a href="https://github.com/bitcraft/PyTMX">https://github.com/bitcraft/PyTMX</a>: A python library for reading .tmx map files.</p>
</li>
<li>
<p><a href="http://ootips.org/mvc-pattern.html">http://ootips.org/mvc-pattern.html</a>: A nice MVC paradigm. Here I replaced the weakly-typed references with our event manager.</p>
</li>
<li><a href="http://ezide.com/games/writing-games.html">http://ezide.com/games/writing-games.html</a>: touches on a basic implementation which this document started from. It expands the model to include networking support, which I have omitted.</li>
</ul>